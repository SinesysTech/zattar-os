/**
 * Next.js Middleware for:
 * - Supabase session management
 * - Security headers
 * - IP blocking/whitelisting
 * - Multi-app routing (website, dashboard, portal)
 */

import { createServerClient } from "@supabase/ssr";
import { NextResponse, type NextRequest } from "next/server";
import {
  applySecurityHeaders,
  shouldApplySecurityHeaders,
  generateNonce,
} from "@/middleware/security-headers";
import { getClientIp } from "@/lib/utils/get-client-ip";
import {
  isIpBlocked,
  isIpWhitelisted,
  getBlockInfo,
} from "@/lib/security/ip-blocking";

// CRITICAL: Add safety check at module load time
if (!process.env.NEXT_PUBLIC_SUPABASE_URL || !process.env.NEXT_PUBLIC_SUPABASE_PUBLISHABLE_OR_ANON_KEY) {
  console.warn(
    '[Middleware Init] Missing critical env vars - will handle gracefully at runtime'
  );
}

/**
 * Middleware para gerenciar autenticação Supabase e roteamento multi-app
 *
 * ARQUITETURA BASEADA EM DIRETÓRIOS:
 * - Website: / (raiz) -> Público
 * - Dashboard: /app/* -> Requer autenticação Supabase
 * - Portal do Cliente: /portal/* -> Requer sessão CPF
 *
 * Responsabilidades:
 * 1. Atualizar sessão do usuário automaticamente
 * 2. Redirecionar usuários não autenticados para /login
 * 3. Permitir acesso a rotas públicas
 * 4. Não interferir em rotas de API (elas têm sua própria autenticação)
 */
export async function middleware(request: NextRequest) {
  let supabaseResponse = NextResponse.next({
    request,
  });

  const pathname = request.nextUrl.pathname;

  // Assets públicos que não precisam de processamento
  const isPublicRootAsset =
    pathname === "/sw.js" ||
    pathname === "/manifest.json" ||
    pathname === "/robots.txt" ||
    pathname === "/favicon.ico" ||
    pathname.startsWith("/workbox-") ||
    pathname.startsWith("/android-chrome-") ||
    pathname.startsWith("/apple-touch-icon");

  if (isPublicRootAsset) {
    return supabaseResponse;
  }

  // ============================================================================
  // IP BLOCKING CHECK
  // ============================================================================

  // Endpoints que não devem ser bloqueados
  const ipBlockingExceptions = [
    "/api/health",
    "/api/csp-report",
  ];

  const isIpBlockingExcepted = ipBlockingExceptions.some((path) =>
    pathname.startsWith(path)
  );

  if (!isIpBlockingExcepted) {
    const clientIp = getClientIp(request);

    // Check whitelist first (fast path)
    const whitelisted = await isIpWhitelisted(clientIp);

    if (!whitelisted) {
      // Check if IP is blocked
      const blocked = await isIpBlocked(clientIp);

      if (blocked) {
        const blockInfo = await getBlockInfo(clientIp);
        console.warn(`[Security] Blocked IP attempt: ${clientIp}`, {
          pathname,
          reason: blockInfo?.reason.type,
          blockedAt: blockInfo?.blockedAt,
          expiresAt: blockInfo?.expiresAt,
        });

        return new NextResponse("Access Denied", {
          status: 403,
          statusText: "Forbidden",
          headers: {
            "Content-Type": "text/plain",
            "X-Blocked-Reason": blockInfo?.reason.type || "unknown",
          },
        });
      }
    }
  }

  // Gerar nonce para CSP
  const nonce = generateNonce();

  // Headers de debug e segurança
  const applyHeaders = (response: NextResponse) => {
    // Debug headers
    response.headers.set("x-zattar-pathname", pathname);
    response.headers.set("x-zattar-app-type", getAppType(pathname));

    // Security headers (se aplicável)
    if (shouldApplySecurityHeaders(pathname)) {
      applySecurityHeaders(response.headers, nonce);
    }

    return response;
  };

  // Determinar qual app baseado no path
  function getAppType(path: string): "website" | "dashboard" | "portal" {
    if (path.startsWith("/app")) return "dashboard";
    if (path.startsWith("/portal")) return "portal";
    return "website";
  }

  const appType = getAppType(pathname);

  // Detectar endpoints /api/* desconhecidos para acionar auto-blocking
  // (ex.: >20 requisições inválidas em 5min)
  function isKnownEndpoint(path: string): boolean {
    const knownApiPrefixes = [
      '/api/acervo',
      '/api/admin',
      '/api/ai',
      '/api/assinatura-digital',
      '/api/auth',
      '/api/cache',
      '/api/captura',
      '/api/clientes',
      '/api/copilotkit',
      '/api/cron',
      '/api/csp-report',
      '/api/debug',
      '/api/docs',
      '/api/enderecos',
      '/api/fornecedores',
      '/api/health',
      '/api/mcp',
      '/api/me',
      '/api/pastas',
      '/api/pendentes-manifestacao',
      '/api/perfil',
      '/api/permissoes',
      '/api/pje',
      '/api/plate',
      '/api/templates',
      '/api/tipos-expedientes',
      '/api/tribunais',
      '/api/webhooks',
    ];

    return knownApiPrefixes.some(
      (prefix) => path === prefix || path.startsWith(`${prefix}/`)
    );
  }

  // ============================================================================
  // WEBSITE - Público (raiz /)
  // ============================================================================
  if (appType === "website") {
    // Website é sempre público, apenas passar
    return applyHeaders(supabaseResponse);
  }

  // ============================================================================
  // PORTAL DO CLIENTE - Requer sessão CPF (/portal/*)
  // ============================================================================
  if (appType === "portal") {
    // Permitir acesso à página de login do portal
    if (pathname === "/portal" || pathname === "/portal/") {
      return applyHeaders(supabaseResponse);
    }

    // Verificar cookie de sessão do portal
    const portalCookie = request.cookies.get("portal-cpf-session");
    if (!portalCookie) {
      const url = request.nextUrl.clone();
      url.pathname = "/portal";
      return applyHeaders(NextResponse.redirect(url));
    }

    // Sessão válida, permitir acesso
    return applyHeaders(supabaseResponse);
  }

  // ============================================================================
  // DASHBOARD - Requer autenticação Supabase (/app/*)
  // ============================================================================

  // Rotas de API não devem ser bloqueadas pelo middleware
  // Elas têm sua própria lógica de autenticação
  if (pathname.startsWith("/api/")) {
    if (!isKnownEndpoint(pathname)) {
      // Registrar atividade suspeita (ignora erros em Edge Runtime)
      try {
        await recordSuspiciousActivity(
          getClientIp(request),
          'invalid_endpoints',
          pathname
        );
      } catch (error) {
        // Ignorar erros na segurança (graceful degradation)
        // Edge Runtime pode não ter acesso a Redis
        console.debug('Could not record suspicious activity:', error instanceof Error ? error.message : 'Unknown error');
      }
    }
    return applyHeaders(supabaseResponse);
  }

  // Rotas públicas do dashboard (login, signup, etc)
  const publicDashboardRoutes = [
    "/app/login",
    "/app/sign-up",
    "/app/sign-up-success",
    "/app/forgot-password",
    "/app/update-password",
    "/app/confirm",
    "/app/error",
  ];

  // Rotas públicas globais (assinatura digital, formulários)
  const globalPublicRoutes = [
    "/assinatura",
    "/formulario",
  ];

  const isPublicRoute =
    publicDashboardRoutes.some((route) => pathname.startsWith(route)) ||
    globalPublicRoutes.some((route) => pathname.startsWith(route));

  // Validar variáveis de ambiente obrigatórias
  const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL;
  const supabaseKey = process.env.NEXT_PUBLIC_SUPABASE_PUBLISHABLE_OR_ANON_KEY;

  if (!supabaseUrl || !supabaseKey) {
    console.error(
      "Missing required environment variables: NEXT_PUBLIC_SUPABASE_URL or NEXT_PUBLIC_SUPABASE_PUBLISHABLE_OR_ANON_KEY"
    );
    return NextResponse.next();
  }

  // Criar cliente Supabase para middleware
  const supabase = createServerClient(
    supabaseUrl,
    supabaseKey,
    {
      cookies: {
        getAll() {
          return request.cookies.getAll();
        },
        setAll(cookiesToSet) {
          cookiesToSet.forEach(({ name, value }) => {
            request.cookies.set(name, value);
          });
          supabaseResponse = NextResponse.next({
            request,
          });
          cookiesToSet.forEach(({ name, value, options }) => {
            supabaseResponse.cookies.set(name, value, options);
          });
        },
      },
    }
  );

  // Atualizar e validar sessão
  await supabase.auth.getSession();

  const {
    data: { user },
    error: authError,
  } = await supabase.auth.getUser();

  // Se não está autenticado e não é rota pública, redirecionar para login
  if ((!user || authError) && !isPublicRoute) {
    try {
      await supabase.auth.signOut();
    } catch {
      // Ignorar erros ao fazer signOut
    }

    const url = request.nextUrl.clone();
    url.pathname = "/app/login";
    url.searchParams.set("redirectTo", pathname);

    const redirectResponse = NextResponse.redirect(url);

    // Limpar cookies inválidos
    const cookiesToDelete = [
      "sb-access-token",
      "sb-refresh-token",
      "sb-provider-token",
      "sb-provider-refresh-token",
    ];

    if (supabaseUrl) {
      try {
        const projectRef = new URL(supabaseUrl).hostname.split(".")[0];
        cookiesToDelete.push(`sb-${projectRef}-auth-token`);
        cookiesToDelete.push(`sb-${projectRef}-auth-token-code-verifier`);
      } catch {
        // Ignorar erro ao extrair project ref
      }
    }

    cookiesToDelete.forEach((cookieName) => {
      redirectResponse.cookies.delete(cookieName);
      redirectResponse.cookies.set(cookieName, "", {
        expires: new Date(0),
        path: "/",
        sameSite: "lax",
        httpOnly: true,
        secure: process.env.NODE_ENV === "production",
      });
    });

    return applyHeaders(redirectResponse);
  }

  return applyHeaders(supabaseResponse);
}

export const config = {
  matcher: [
    /*
     * Match all request paths except:
     * - _next/static (static files)
     * - _next/image (image optimization files)
     * - favicon.ico (favicon file)
     * - images - .svg, .png, .jpg, .jpeg, .gif, .webp
     */
    "/((?!_next/static|_next/image|favicon.ico|.*\\.(?:svg|png|jpg|jpeg|gif|webp)$).*)",
  ],
};
